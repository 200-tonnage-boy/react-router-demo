## 初始化
### react-router-dom
  在使用rrd时，可以引入 BrowserRouter as Router,HashRouter,Route等组件，用于如下路由
  ~~~JavaScript
    <HashRouter>
    <div>
      <ul>
        <li>
          <a href="#/a">to A</a>
        </li>
        <li>
          <a href="#/b">to B</a>
        </li>
      </ul>
    </div>
    <div style={{ height: "500px", border: "1px solid" }}>
      <Route exact path="/a">
        <span>页面A</span>
      </Route>
      <Route path="/b">
        <span>页面B</span>
      </Route>
    </div>
  </HashRouter>
  ~~~

  注意其中HashRouter/BrowserRouter在rrd中创建，但是主要还是依赖rr与history两个库，源码中的核心定义如下：
  ~~~JavaScript
    function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = history.createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter.prototype;
  _proto.render = function render() {
    return React.createElement(reactRouter.Router, {
      history: this.history,
      children: this.props.children
    });
  };
  ~~~
可以看到其中主要是通过history中的createHashHistory方法创建一个history对象，并传递进rr库到处的Router组件中，BrowserRouter组件完全一样，只是history属性是由createBrowserHistory方法返回；
至于其他的如route导出，则是直接将rr库的对应部分进行导出，以Route为例：
~~~JavaScript
Object.defineProperty(exports, 'Route', {
  enumerable: true,
  get: function () {
    return reactRouter.Route;// 这个reactRouter是引用的rr库
  }
});
~~~

## Router/Route
  Route中的组件的props会多出3个属性
  - history: 路由功能，跳转拦截等等
  - location：URL信息，路径名等等 
  - match：匹配信息，是否精确匹配等

  根据上面，在使用<HashRouter />和<BrowserRouter />时其内部其实是渲染的Router组件，该组件由react-router提供；使用时内部嵌套Route组件；

### Router
  该组件内部负责渲染route，并给route提供history和location，是通过HashRouter组件创建并通过props传递进来的
  该组件通过调用history库的listen方法来监听路由的变化，变化后将最新的location信息更新至State，从而引起更新传递进Route中
### Route
  该组件组要是通过传递进来的location的pathname校验path来确定是否渲染component(path component为使用Route组件时传递的props)，并将路由信息传递给要渲染的组件

  **tips: 注意在源码中，match也会传递给Route，并不完全由Route生成；** ；

### 总结
- router：
  - 创建一个监听函数，该函数组由props.history提供（rrd中调用history生成的）；该函数在路由变化的时候触发，并能获取最新的信息，变化后router组件setState从而触发重新渲染，更新子组件，子组件就是route
  - 创建一个context，传递进去history  最新的location等（注意mach有时是会传递进去的，不都是在route组件中生成的）
- route:
  - 接受上面传递来的路由相关的信息，并根据路径判断是否需要渲染组件；
  - 将history/match/location传递给要渲染的组件；
## hashRouter 
  前面已经实现了Router和route组件，主要做的是监听路由的变化，已经判断组件是否需要渲染；但是一个重要的属性location和history都是RRD的HashRouter传递的history提供的（location通过listen方法获取，该方法也是通过history获取的）
  主要是调用createHashHistory实现；
  该方法主要注意以下几点：
  - 无论hash还是h5，其栈的维护规则与h5一样，先多次push，然后再回退到之前的历史，此时再次push，会把后面的都截断；
  - hash模式下主要是通过hashchange监听hash变化，然后更新对应的变量
  - 方法返回一个history对象，主要是包含go push foward goBack, location 等属性，每次监听到hash变化的时候就更新该对象的loaction属性，
  - 维护一个lisatener数组，每次hash变化的时候循环调用该数组，实现router组件中的功能，并且返回一个卸载函数；
  - 维护一个调用栈数组，以及索引，和state,用于前进或者后退

**tips:** 
- 这样实现浏览器的前进按钮是灰色的，因此其实history源码里还是通过history的栈来维护的，并没有自己维护一个栈结构；
- history 目前最新版本是v5，该版本引入了破坏性更改，hash模式下也用原生的html 5 history实现，因此不再支持不支持HTML5 History的浏览器；目前安装react-router-dom还是会安装，4.10.1（package 中是4.9^因此是大于4.9 小于5.0）
- **注意state传参刷新页面不会丢失（hash模式下会丢失，且进行回退操作的时候,如果是hash模式state是undefined，如果是browser模式会有记录；官网文档形容hash模式下是不支持location.state的，但是实际使用是可以的，不过会有些表现异常，比如前面说的）**；
- 注意push多次后，再多次回退，此时再次push，后面的记录会全部丢失；
- `('/b',{name:'xxx'})`;`{pathname:'/b',state:{name:'xxx'}}` 使用props.history.push传参的时候应该是支持这两种形式的，hash模式下第一种是不行的，browser可以

## browser
  createBrowser的实现与hash类型，不过其只是通过浏览器自己的history对象来维护；主要实现的点就在于pushState和replaceState两个API；可以改变URL但是又不会发起请求；
  注意的是我们在针对push和go分别处理，因为go API会触发popstate事件，push和replace不会，因此要手动触发更新状态，以及触发listener调用，从而实现页面变化；

## 随笔

  - react-router跳转传参主要方式整理：query,match,url，state
  - hash模式下：注意，如果只是通过监听hashchange的话，浏览器按钮的前进按钮是会变灰的,因为代码里的go是通过自己维护一个栈实现的，go-1对浏览器来说也是push一个；所以源码也是history 维护  go还是调用的history
  - browser模式下，两种方式：一种是自定义个监听函数，监听replace和pushState的变化；（自定义事件？）；另外就是自己定义个
  - 关于发起请求，刷新的时候都会发起请求，**区别在于browser会把后面的地址带上**；因此才需要后端去兼容不同的地址；而之所以能实现前端browser路由，在于pushState/replaceState这两个API，改变地址和state而不发起请求；而不是history本身
  - browser可以实现保存state，刷新，回退前进后也不丢失，hash模式是不行的
  - 注：通过history源码可以发现，hash模式下，如果push传递了第二个参数，会被忽略，而如果第一个参数是个对象，则会直接解构给location,所以解释了为什么`('/b',{name:'xxx'})` 不可用;而`{pathname:'/b',state:{name:'xxx'}}`却能接收到state;**history库只是将state当做一个属性解构到location**;并不是值得browser里面的state；